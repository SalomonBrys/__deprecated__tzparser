<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="fr" xml:lang="fr">
<head>
	<title>TzParser : Documentation FR</title>

	<style type="text/css">
		*
		{
			padding: 0;
			margin: 0;
		}
		
		body
		{
			font-family: Verdana, sans-serif;
			font-size: 13px;
			background-color: black;
			color: white;
			padding: 10px;
			width: 884px;
			margin: 10px auto;
			border: solid #6666AA 1px;
		}
		
		h1
		{
			text-align: center;
			padding: 10px;
		}
		
		h2
		{
			padding: 15px 0 0 0;
		}
		
		h3
		{
			padding: 15px 0 0 5px;
		}
		
		ul
		{
			padding: 5px 0 5px 20px;
			list-style-position: inside;
		}
		
		a
		{
			color: White;
			text-decoration: underline;
		}
		
		a.sharp
		{
			text-decoration: none;
		}
		
		pre
		{
			background-color: #CCCCFF;
			color: Black;
			width: 795px;
			margin: 0 0 5px 42px;
			padding: 4px;
		}
		
		p
		{
			padding: 10px 0 5px 10px;
		}
		
		span.com
		{
			color: #006633;
		}
	</style>

</head>
<body onload="bodyOnLoad();">

<h1>TzParser</h1>

<h2>Table of Contents</h2>

<ul>
	<li>
		<a href='#pres'>Presentation</a>
	</li>
	<li>
		<a href='#bnf'>Writing a parser in TzBNF using TzParser</a>
		<ul>
			<li><a href='#bnfBase'>Syntax and basic rules</a></li>
			<li><a href='#bnfNeed'>Optionality, repetition and checking</a></li>
			<li><a href='#bnfTz'>Special rules (TzRule) and modifiers (TzModif)</a></li>
			<li><a href='#bnfGroup'>Groups</a></li>
			<li><a href='#bnfAST'>Saving into the AST</a></li>
			<li><a href='#bnfEx'>Example</a></li>
		</ul>
	</li>
	<li>
		<a href='#cpp'>Writing a parser in C++ using TzParser, correspondence to the TzBNF</a>
		<ul>
			<li><a href='#cppBase'>Syntax and basic rules</a></li>
			<li><a href='#cppTz'>Special rules (TzRule)</a></li>
			<li><a href='#cppNeed'>Optionality, repetition, checking and modifiers (TzModif)</a></li>
			<li><a href='#cppGroup'>Groups</a></li>
			<li><a href='#cppAST'>Saving into the AST</a></li>
			<li><a href='#cppEx'>Example</a></li>
		</ul>
	</li>
	<li>
		<a href='#use'>Using a parser in C++ created or generated with TzParser</a>
		<ul>
			<li><a href='#useBase'>Basic use</a></li>
			<li><a href='#useStream'>Creating a stream for TzParser</a></li>
			<li><a href='#useAST'>Interfacing an AST library</a></li>
		</ul>
	</li>
	<li>
		<a href='#moreCpp'>How to create advanced rules in C++ ?</a>
	</li>
	<li>
		<a href='#end'>Bugs ? Contact ? Next ?</a>
	</li>
</ul>

<h2><a name="pres" class="sharp">Presentation</a></h2>

<p>
	This documentation is based on the assumption that you already have a basic knowledge of LL parsing and therefore will not describe how a LL parser works.<br />
	If you should need it : <a href="http://fr.wikipedia.org/wiki/Analyse_LL">http://fr.wikipedia.org/wiki/Analyse_LL</a> (French version) and <a href="http://en.wikipedia.org/wiki/LL_parser">http://en.wikipedia.org/wiki/LL_parser</a> (English version).
</p>

<p>
	TzParser is both a LL parsing library in C++ and a software that generates LL parsers in C++.<br />
	This library was created by Salomon BRYS (salomon . brys @ gmail . com) to allow any programmer to easily generate a LL parser that works with any syntax.
</p>

<p>
	The TzParser library is a library which allows the easy creation of a parser in C++ which can be integrated into your application.<br />
	It is derived from the BNF so as to easily create parsers.<br />
	It allows the parsing of a flux in order to get an AST (Abstract Syntaxe Tree) depending on the syntax.
</p>

<p>
	The TzParser software is a software which generates parsing code in C++, using the TzParser library based upon a BNF file.<br />
</p>

<h2><a name="bnf" class="sharp">Writing a parser in TzBNF using TzParser</a></h2>

<h3><a name="bnfBase" class="sharp">Syntax and basic rules</a></h3>

<p>
	The syntax of the TzBNF is very much inspired by the BNF (Bachus Naur Form).<br />
	It allows to describe in a declerative manner the syntaxic rules of a language.<br />
	Here follows an empty <i>test</i> rule :
</p>

<pre>
<span class="com">// Comment here</span>
test	::=
;
<span class="com">/* Comment here */</span>
</pre>

<p>
	TzParser provides a certain number of basic rules that allow the creation of more advanced rules :
</p>

<pre>
<span class="com">/*
  Implicit rules.
*/</span>
'c'         <span class="com">// Parses character c</span>
"hello"     <span class="com">// Parses character string <i>hello</i></span>

<span class="com">/*
  Basic rules.
  Please note that all the Tzparser basic rules start with a capital letter.
*/</span>
GetChar     <span class="com">// Parses any character. Fails only if it is the end of the file</span>
Identifier  <span class="com">// Parses an identifier (a series of letters, digits or underscores which does not start</span>
            <span class="com">// by a digit)</span>
Integer     <span class="com">// Parses an integer</span>
Float       <span class="com">// Parses a float</span>
QuotedPair  <span class="com">// Parses the character \ followed by another simple character. For instance : \n</span>
CInChar     <span class="com">// Parses either a simple character, or a QuotedPair</span>
CChar       <span class="com">// Parses a character in C standards. For instance : 'c', '\n'</span>
CStr        <span class="com">// Parses a character string in C standards. For instance : "Salut le \"monde\" !\n"</span>
EndOfFile   <span class="com">// Fails if the end of the file is not reached</span>
</pre>

<p>
	Let us create an <i>affect</i> rule which shall parse a very simple affectation of an integer in C standards :
</p>

<pre>
<span class="com">// Parses an affectation of the following type : "mavar = 42;"</span>
affect	::=
    Identifier '=' Integer ';'
;
</pre>

<p>
	TzBNF also allows you to create or to concatenate strings.<br />
	Furthermore, TzBNF provides you with several pre-existing strings (Useless at this point, but their utility will be defined later in this chapter). Please note that the [x-y] syntax is not part of TzBNF and is present in this example only for clarity.<br />
	By convention, the names of the strings are written in capital letters.
</p>

<pre>
<span class="com">/*
  Creation strings
*/</span>
NOM = "Salomon";                             <span class="com">// Simple string</span>
BONJOUR = "Bienvenue, " . NOM                <span class="com">// Concatenation</span>
POINT = '.'                                  <span class="com">// Simple string</span>
MESSAGE = BONJOUR . POINT . ' ' . "Ca va ?"  <span class="com">//Concatenation</span>

<span class="com">/*
  Using a string within a rule
*/</span>
Test	::=
    NOM  <span class="com">// Parse "Salomon"</span>
;

<span class="com">/*
  Standard string definied by TzBNF
*/</span>
P_HT       = '\t';                   <span class="com">// Tab</span>
P_SP       = ' ';                    <span class="com">// Space</span>
P_LBLANKS  = P_HT . P_SP;            <span class="com">// Linear blank characters</span>

P_CR       = '\r';                   <span class="com">// Carriage return</span>
P_LF       = '\n';                   <span class="com">// New line under Unix</span>
P_CRLF     = P_CR . P_LF;            <span class="com">// New line under Windows</span>
P_NL       = P_CRLF;                 <span class="com">// P_CRLF alias</span>

P_BLANKS   = P_LBLANKS . P_CRLF;     <span class="com">// Blank characters</span>

P_UPALPHA  = [A-Z];                  <span class="com">// Capital letters</span>
P_LOALPHA  = [a-z];                  <span class="com">// small letters</span>
P_ALPHA    = P_UPALPHA . P_LOALPHA;  <span class="com">// Capital and small letters</span>

P_NUM      = [0-9];                   <span class="com">// Digits</span>
P_DIGIT    = P_NUM;                  <span class="com">// P_NUM alias</span>

P_ALPHANUM = P_ALPHA . P_NUM;        <span class="com">// Alphabet and digits</span>

P_CTL      = [...];                  <span class="com">// Any control ASCII character : from 1 to 31 and 127</span>

P_TEXT     = [...];                  <span class="com">// Any text ASCII character : from 32 to 126</span>

P_CHAR     = P_CTL . P_TEXT;         <span class="com">// Any ASCII character except 0</span>

P_HEX      = "ABCDEF" . P_NUM;       <span class="com">// Hexadecimal characters</span>
</pre>

<h3><a name="bnfNeed" class="sharp">Optionality, repetition and checking</a></h3>

<p>
	Certain rules can be optional or repetitive.<br />
	TzBNF allows the easy management of Optionality or repetition of a rule (N represents the infinite) :
</p>

<pre>
<span class="com">/*
  Simple indicators.
*/</span>
regle?          <span class="com">// Parses the rule 0 or 1 time</span>
regle*          <span class="com">// Parses the rule from 0 to N time(s)</span>
regle+          <span class="com">// Parses the rule from 1 to N time(s)</span>

<span class="com">/*
  Advanced indicators.
  In the following examples, the characters in between commas and braces are given for the purpose
  of the example.
*/</span>
regle{2}        <span class="com">// Parses the rule twice</span>
regle{+}        <span class="com">// Parses the rule from 1 to N time(s), the equivalent of regle+</span>
regle{+, '-'}   <span class="com">// Parses the rule from 1 to N time(s), separated by '-' characters</span>
regle{2, '-'}   <span class="com">// Parses the rule twice, separated by '-' characters</span>
regle{,}        <span class="com">// Parses the rule from 0 to N time(s), the equivalent of regle* : no min or max,</span>
                <span class="com">// the equivalent of regle{0,0}</span>
regle{2,}       <span class="com">// Parses the rule from 2 to N time(s), the equivalent of regle{2,0}</span>
regle{,4}       <span class="com">// Parses the rule from 0 to 4 time(s), the equivalent of regle{0,4}</span>
regle{2,4}      <span class="com">// Parses the rule from 2 to 4 time(s)</span>
regle{,,'-'}    <span class="com">// Parses the rule from 0 to N time(s), separated by '-' characters, the equivalent</span>
                <span class="com">// of regle{*,'-'}, also of regle{0,0,'-'}</span>
regle{2,,'-'}   <span class="com">// Parses the rule from 2 to N time(s), separated by '-' characters, the equivalent</span>
                <span class="com">// of regle{2,0,'-'}</span>
regle{,4,'-'}   <span class="com">// Parses the rule from 0 to 4 time(s), separated by '-' characters, the equivalent</span>
                <span class="com">// of regle{0,4,'-'}</span>
regle{2,4,'-'}  <span class="com">// Parses the rule from 2 to 4 time(s), separated by '-' characters</span>
</pre>

<p>
	Let us go back to the <i>affect</i> rule and make it so that it can also parse an affectation upon creation :
</p>

<pre>
<span class="com">// Parses an affectation of the type "mavar = 42;" or "int mavar = 42;"</span>
<span class="com">// We admit that the rule <i>type</i> has already been created</span>
affect	::=
    type? Identifier '=' Integer ';'
;
</pre>

<p>
	The TzBNF allows you to check a rule without consuming it.<br />
	If the rule is preceded by the character '=', TzParser will parse but will not consume the rule.<br />
	That is to say that the rule will fail if it is not parsed and the following rule will start at the same point as the checked rule (and not following it).<br />
	If the rule is preceded by the character '!', TzParser will check that the rule IS NOT parsed.<br />
	This behaviour allows you to check for certain particular cases and to optimize your parser to check a simple generic rule before entering a more complex rule.
</p>

<pre>
Identifier =Float      <span class="com">// Tests the rule which parses an identifier and checks if it is followed by a</span>
                       <span class="com">// float without consuming the float</span>

Identifier !Float{2,}  <span class="com">// Tests the rule which parses an identifier and checks that it is not followed</span>
                       <span class="com">// by at least two floats</span>  
</pre>

<h3><a name="bnfTz" class="sharp">Special rules (TzRule) and modifiers (TzModif)</a></h3>

<p>
	The TzBNF includes a set of special rules which can take arguments.<br />
	Those rules start with the character '#'.<br />
	The arguments are of a litteral type (that is to say a 'c'haracter, a "string", a "conc"."atenation" or the name of a string), boolean (+ for true and - for false) or eventually NULL (0).
</p>

<pre>
<span class="com">/*
  #GetChar can take 0, 1, 2 or 3 arguments
  arg 1 : Optional boolean, + if the GetChar is to be insensible to case, - (default) otherwise
  arg 2 : Litteral or NULL, character or character string representing a list of characters to be
          parsed
  arg 3 : Litteral, character or character string representing a list of characters not to be parsed
*/</span>
#GetChar()                 <span class="com">// The equivalent of GetChar</span>
#GetChar(P_ALPHA)          <span class="com">// Parses any character in P_ALPHA</span>
#GetChar(+, P_LOWALPHA)    <span class="com">// Parses from 1 to N time(s) the equivalent of the previous example</span>
                           <span class="com">// because it is insensible to case</span>
#GetChar(P_NUM, '0')       <span class="com">// Parses any character in P_NUM but 0</span>
#GetChar(+, P_HEX, P_NUM)  <span class="com">// Parses from 1 to N time(s) any character in P_HEX but for those in</span>
                           <span class="com">// P_NUM while not respecting case (takes into account upper AND lower</span>
  			   <span class="com">// case)</span>
#GetChar("ABCDEFabcdef")   <span class="com">// The equivalent of the previous example</span>
#GetChar(+, 0, P_NUM)      <span class="com">// Parses from 1 to N time(s) any character that is not in P_NUM</span>

<span class="com">/*
  <i>#ReadUntil</i> takes a litteral as an argument
  Keeps on parsing until it encounters this string or it fails if the end of the file is reached
*/</span>
"/*" #ReadUntil("*/")      <span class="com">// Parses a C comment : parses from <span class="com">/* to the first */</span></span>

<span class="com">/*
  <i>#Identifier</i> can take 0 or 1 boolean argument
  If the argument is -, an identifier will be parsed while allowing the first character to be a
  digit
*/</span>
#Identifier                <span class="com">// The equivalent of <i>Identifier</i></span>
#Identifier(+)             <span class="com">// The equivalent of <i>Identifier</i> (+ is the default value)</span>
#Identifier(-)             <span class="com">// Parses an identifier without checking the first character</span>
                           <span class="com">// WARNING : This instruction parses 42coucou21</span>
                           <span class="com">//             but also any positive integer such as 4221</span>

<span class="com">/*
  <i>#Integer</i> can take 0 or 1 boolean argument
   If it is defined, the first argument defines if the integer is to be positive or negative.
*/</span>
#Integer                   <span class="com">// The equivalent of <i>Integer</i></span>
#Integer(+)                <span class="com">// Parses a positive integer such as 2142</span>
#Integer(-)                <span class="com">// Parses a negative integer such as -84</span>

<span class="com">/*
  <i>#Float</i> can take 0, 1 or 2 arguments
  arg 1 : Optional boolean, just like <i>#integer</i>, defines if the float is to be positive or negative
  arg 2 : Optional character, defines the character used as a decimal point, default is '.'
*/</span>
#Float                     <span class="com">// The equivalent of <i>Float</i></span>
#Float(-)                  <span class="com">// Parses a negative float, such as -21.42</span>
#Float(',')                <span class="com">// Parses a float with ',' as a decimal point</span>
                           <span class="com">//   For instance : 21,42 or -21,42</span>
#Float(+, ',')             <span class="com">// Parses a positive float with ',' as a decimal point</span>
                           <span class="com">//  For instance : 21,42</span>
</pre>

<p>
	The TzBNF includes a few modifiers which allow the modification of the behaviour of a rule.
</p>

<pre>
<span class="com">/*
  >Ignore() allows to ignore all the characters of a string or anything that will be parsed by a
  given rule
*/</span>
>Ignore(LBLANKS) declaration  <span class="com">// Parses the <i>declaration</i> rule in which all the linear blank</span>
                              <span class="com">// characters will be ignored</span>
>Ignore(CIgnore) declaration  <span class="com">// Parses the <i>declaration</i> rule in which all that is parsed</span>
                              <span class="com">//    by the <i>CIgnore</i> rule (already defined) will be ignored</span>
>Ignore() declaration         <span class="com">// Parses the <i>declaration</i> rule taking everything into account </span>
                              <span class="com">// (overrides the <i>ignore</i> for this rule if it is defined by the caller</span>
                              <span class="com">// rule)</span>

<span class="com">/*
  >NoIgnore will not parse the <i>ignore</i> rule before the given rule.
  WARNING : This rule is VERY different from >Ignore(). If you wish to take everything into account
            WITHIN the rule, you must use >Ignore(), whereas if you wish to take everything into
            account BEFORE the rule, you must use >NoIgnore 
*/</span>
declaration >NoIgnore ';'     <span class="com">// Parses the <i>declaration</i> rulefollowed by the character ';' WITHOUT</span>
                              <span class="com">// ignoring anything defined previously in between the declaration</span>
			      <span class="com">// and the character ';'</span>	
<span class="com">/*
  >Force() forces the rule to succeed, and it generates a parse error if the rule fails.
  It takes as a parameter the string which will be used as the text of the parse error.
*/</span>
>Force("EOF !!!") EndOfFile   <span class="com">// Generates a parse error if it is not the end of the file</span>
</pre>

<h3><a name="bnfGroup" class="sharp">Groups</a></h3>

<p>
	The TzBNF allows the regrouping of rules into groups using the characters [].<br />
	Those groups also allow the parsing of a certain rule instead of others by using the character |.<br />
	A group is a rule itself, just like any other, and as such, it can be assigned anything that can be assigned to other rules.
</p>

<pre>
<span class="com">/*
  Test1 rule which parses an Identifier followed by an unknown number of ',' Identifier
  The equivalent of Identifier{+, ','}
*/</span>
Test1	::=
    Identifier
    [ ',' Identifier]*
;

<span class="com">/*
  Test2 rule which parses either an Integer or a Float.
  Please note that the group MUST be in that precise order since Float has the ability
  to parse an Integer => A float does not necessarily have a decimal point
*/</span>
Test2	::=
    [ Float | Integer ]
;
</pre>

<h3><a name="bnfAST" class="sharp">Saving into the AST</a></h3>

<p>
	Tzparser's ASt system is based upon XML.<br />
	Even though you can (see lower down) interface any system (XML or not), the principle is still based upon XML and this documentation is only concerned with the AST in XML form.<br />
	In the TzBNF, there are two possible ways of saving into the tree : Creating a node child of the previous one or creating an attribute within the previous node.
</p>

<pre>
regle:id            <span class="com">// Parses the rule, creates an <i>id</i> node and saves what has been parsed</span>
                    <span class="com">// into the <i>value</i> attribute of the newly created node</span>
regle:!id           <span class="com">// Parses the rule and creates an <i>id</i> node without saving what has been parsed</span>
regle:id.           <span class="com">// Parses the rule, creates an <i>id</i> node, saves what has been parsed and saves</span>
                    <span class="com">// the current line into the <i>Line</i> attribute of the newly created node</span>
regle:!id.          <span class="com">// Parses the rule, creates an <i>id</i> node without saving what has been parsed and</span>
                    <span class="com">// saves the current line in the <i>Line</i> attribute of the newly created node</span>
regle:&lt;idval&gt;       <span class="com">// Parses the rule and saves what has been parsed into the <i>idval</i> attribute of</span>
                    <span class="com">// the previous node</span>
regle:&lt;type "id"&gt;   <span class="com">// Parses the rule and creates a <i>type</i> attribute with <i>id</i> as a value in the</span>
                    <span class="com">// previous node. Please note that any character, string, concatenation, or name</span>
                    <span class="com">// of a string could have been used instead of "id".</span>
regle:id:&lt;type "id"&gt;<span class="com">// Parses the rule, creates a <i>type</i> attribute with <i>id</i> as a value in the previous</span>
                    <span class="com">// node, then creates a new <i>id</i> node, saves what has been parsed in the newly</span>
                    <span class="com">// created node.</span>
</pre>

<h3><a name="bnfEx" class="sharp">Example</a></h3>

<p>
	Here comes an example using all the afore-mentionned notions :
</p>

<pre>
Test		::=
    Prec*
    Check?:!Check
    >Ignore(P_LBLANKS)
    [
        In:&ltpoint '1'&gt; ='.'
    |
        In:&ltpoint '0'&gt;
    ]:In
    >NoIgnore After?
;
</pre>

<p>
	Creates a <i>Test</i> rule, which parses from 0 to N <i>Prec</i> then 0 or 1 <i>Check</i>.<br />
	If this <i>Check</i> is parsed, a <i>Check</i> node is created without a <i>value</i> attribute (knowing that all the attributes that will be defined WITHIN this rule will be saved in this attribute if no other node has been defined).<br />
	Then it parses EITHER a In followed by a dot, without consuming this dot, OR an In, while ignoring all the linear blank characters.<br />
	Please pay close attention to the order in which the group is defined. If the simple In had been put first, the dot would never had been parsed since the simple In rule would have succeeded even if it was still followed by a dot.<br />
	An In node is created, which contains a <i>value</i> attribute, itself containing what has been parsed in the group, and a <i>point</i> attribute which contains either '0' or '1' depending on what has been parsed.<br />
	Finally, the <i>After</i> may be parsed (which will parse the character '.', if it is present) without ignoring anything between the group and the itself.
</p>

<h2><a name="cpp" class="sharp">Writing a parser in C++ using TzParser, correspondence to the TzBNF</a></h2>

<h3><a name="cppbase" class="sharp">Syntax and basic rules</a></h3>

<p>
	A parser using TzParser uses 2 files : a .h in which the rules and the strings are declared, and a .cpp in which the rules are implemented.<br />
	See below for how to define a rule and a string in a .h (Please note that the strings are just plain <i>define</i>, and also that the CONCAT macros can be used directly in the code and that they exist up to CONCAT15) :
</p>

<pre>
RULE_DECLARE_SIMPLE(Test);                 <span class="com">// Definition of the <i>Test</i> rule</span>

#define MYSTR     "coucou"                 <span class="com">// Definition of the MYSTR string</span>
#define MYCONCAT  CONCAT3("to", "-", "ma") <span class="com">// Definition of the MYCONCAT string set to "to-ma"</span>
</pre>

<p>
	The syntax of the TzParser in C++ was created to in oreder to make it as easy as possible its transformation into C++, ce chapitre decriras donc principalement comment passer de la TzBNF au C++, ce que fait le generateur TzParser.<br />
	Cependant, comme souvent, la syntaxe C++ permet plus de liberte, que nous verrons en fin de chapitre avec les regles avancees.<br />
	Voici comment implementer la regle Test declaree plus haut qui parse un Identifier suivi d'un Float :
</p>

<pre>
RULE_IMPLEMENT(Test, p)       <span class="com">// arg1: nom de la regle, arg2: variable du parser (p par convention)</span>
{
    p   >>  Identifier().r()  <span class="com">// Parse un Identifier. Utilise la variable definit plus haut.</span>
        >>  Float().r()       <span class="com">// Parse un Float</span>
        ;
    RULE_RETURN(p);           <span class="com">// Return de la regle</span>
}
</pre>

<p>
	Notez que le .r() qui suit Identifier() et Float() n'est pas obligatoire lors d'une compilation sous Visual Studio.<br />
	Ce .r() corrige une aberration de G++ (reference a l'instanciation) et est mis par defaut lors de la generation afin d'etre cross-compatible (tout ce que fait r() est { return *this; } ).
</p>

<p>
	Voici les regles de bases et leurs correspondances en TzBNF (les strings etant des #define, elles sont utilisable comme en TzBNF) :
</p>

<pre>
<span class="com">/*
  Regles implicites
*/</span>
GetChar().only('c')  <span class="com">// => 'c'</span>
Read().str("hello")  <span class="com">// => "hello"</span>

<span class="com">/*
  Regles de base.
*/</span>
GetChar()        <span class="com">// => GetChar</span>
Identifier()     <span class="com">// => Identifier</span>
Integer()        <span class="com">// => Integer</span>
Float()          <span class="com">// => Float</span>
QuotedPair()     <span class="com">// => QuotedPair</span>
CInChar()        <span class="com">// => CInChar</span>
CChar()          <span class="com">// => CChar</span>
CStr()           <span class="com">// => CStr</span>
EndOfFile()      <span class="com">// => EndOfFile</span>
</pre>

<h3><a name="cppTz" class="sharp">Regles speciales (TzRule)</a></h3>

<p>
	Les regles dans le TzParser ont toutes un certains nombre de modificateurs (nous verrons ceux en communs plus tard).<br />
	En plus des modificateurs en communs, les TzRule (regles commencant par un #) correspondent en C++ a des regles qui ont leur propre modificateur.<br />
	Les modificateurs peuvent etre chaines.
</p>

<pre>
<span class="com">/*
  #GetChar :
  arg 1 : Booleen : .caseInsensitive()
  arg 2 : Litteral : .only() pour un caractere OU .in() pour une chaine de caracteres
  arg 3 : Litteral : .but() pour un caractere OU .notIn() pour une chaine de caracteres
*/</span>
GetChar()                                  <span class="com">// => GetChar</span>
GetChar().in(P_LBLANKS)                    <span class="com">// => #GetChar(P_LBLANKS)</span>
GetChar().in(P_NUM).but('0')               <span class="com">// => #GetChar(P_NUM, '0')</span>
GetChar().notIn(P_NUM)                     <span class="com">// => #GetChar(0, P_NUM)</span>
GetChar().in(P_HEX).caseInsensitive(true)  <span class="com">// => #GetChar(+, P_HEX)</span>

<span class="com">/*
  #ReadUntil :
*/</span>
Read().until("*/")                         <span class="com">// => #ReadUntil("*/")</span>

<span class="com">/*
  #Identifier :
  arg 1 : Booleen : .checkFirstChar()
*/</span>
Identifier()                               <span class="com">// => Identifier</span>
Identifier().checkFirstChar(false)         <span class="com">// => #Identifier(-)</span>

<span class="com">/*
  #Integer :
  arg 1 : Booleen : .forcePositive() si +, .forceNegative() si -
*/</span>
Integer()                                  <span class="com">// => Integer</span>
Integer().forcePositive()                  <span class="com">// => #Integer(+)</span>
Integer().forceNegative()                  <span class="com">// => #Integer(-)</span>

<span class="com">/*
  #Float :
  arg 1 : Booleen : .forcePositive() si +, .forceNegative() si -
  arg 2 : Caractere : .coma()
*/</span>
Float()                                    <span class="com">// => Float</span>
Float().forcePositive()                    <span class="com">// => #Float(+)</span>
Float().forceNegative()                    <span class="com">// => #Float(-)</span>
Float().coma(',')                          <span class="com">// => #Float(',')</span>
Float().forcePositive().coma(',')          <span class="com">// => #Float(+, ',')</span>
</pre>

<h3><a name="cppNeed" class="sharp">Optionalite, repetition, verification et modificateurs (TzModif)</a></h3>

<p>
	Dans la syntaxe TzParser, toute operation visant a modifier le comportement d'une regle utilise un modificateur.<br />
	Les modificateurs ci-apres sont communs a toutes les regles (y compris celle definit par l'utilisateur).<br />
	Ces modificateurs doivent imperativement etre appele APRES les eventuels modificateurs propre a une regle.<br />
</p>

<pre>
<span class="com">/*
  L'optionalite et la repetition (geres en TzBNF par les caracteres ?, * et + sont geres en C++ par
  le modificateur .n().
  Ce modificateur peux prendre le caractere TzBNF, un define correspondant au caractere TzBNF ou un
  minimum et un maximum. Pour chaque appel, un eventuel caractere d'espacement peut etre specifie
  en dernier argument.
  ? (= PARSE_ZERO_OR_ONE = PARSE_ZOO), + (= PARSE_ONE_OR_MORE = PARSE_OOM) et * (= PARSE_ANY)
*/</span>
Regle().n('+')                 <span class="com">// => Regle+</span>
Regle().n(PARSE_OOM)           <span class="com">// => Regle+</span>
Regle().n(2, 4)                <span class="com">// => Regle{2, 4}</span>
Regle().n(2, 0)                <span class="com">// => Regle{2,}</span>
Regle().n(2, 2)                <span class="com">// => Regle{2}</span>
Regle().n('+', '-')            <span class="com">// => Regle{+, '-'}</span>
Regle().n(2, 0, '-')           <span class="com">// => Regle{2,,'-'}</span>

<span class="com">/*
  La verification se fait par le modificateur .check().
  check prend en parametre un booleen qui definit si vous voulez verifier la presence ou l'abscence
  d'une regle.
*/</span>
Regle().check(true)            <span class="com">// => =Regle</span>
Regle().check(false)           <span class="com">// => !Regle</span>

<span class="com">/*
  Le modificateur TzBNF >Ignore() correspond au modificateur C++ ignore().
  Attention, si ignore prend en paramettre un nom de regle, n'oubliez pas les parentheses !
*/</span>
Regle().ignore()               <span class="com">// => >Ignore() Regle</span>
Regle().ignore(P_LBLANKS)      <span class="com">// => >Ignore(P_LBLANKS) Regle</span>
Regle().ignore(RegleIgnore())  <span class="com">// => >Ignore(RegleIgnore) Regle</span>

<span class="com">/*
  Le modificateur TzBNF >NoIgnore correspond au modificateur C++ ignoreBefore(false).
  Vous pouvez appeller ignoreBefore(true) si vous manipulez une regle sur laquelle
  ignoreBefore(false) a ete (ou a pu etre) appelle afin d'annuler son effet et respecifier que la
  regle parsera l'ignore avant d'etre parsee.
*/</span>
Regle().ignoreBefore(false);   <span class="com">// => >NoIgnore Regle</span>

<span class="com">/*
  Le modificateur TzBNF >Force() correspond au modificateur C++ force().
  Vous pouvez appeller force() sans arguments si vous voulez annuler le force sur une regle.
*/</span>
Regle().force("ouch !")        <span class="com">// => >Force("ouch !") Regle</span>
</pre>

<h3><a name="cppGroup" class="sharp">Groupes</a></h3>

<p>
	Il existe deux types de groupes : le group simple AND et le groupe conditionnel OR.<br />
	Le groupe OR test chacun de ses membres et s'arrete au premier succes, ce qui signifie que si l'un des ses membres contient plusieurs regles, ca doit etre un groupe AND.
</p>

<pre>
<span class="com">/*
  test1       ::=
      [Identifier float]*
  ;
*/</span>
RULE_IMPLEMENT(test1, p)
{
    p   >>  ( G_AND
            >>  Identifier().r()
            >>  Float().r()
            ).n('*').r()              <span class="com">// Notez les modificateurs apres la fermeture du groupe</span>
        ;
    RULE_RETURN(p);
}

<span class="com">/*
  test2       ::=
      [truc | machin]
  ;
*/</span>
RULE_IMPLEMENT(test2, p)
{
    p   >>  ( G_OR
            >>  truc().r()
            >>  machin().r()
            ).r()
        ;
    RULE_RETURN(p);
}

<span class="com">/*
  test3       ::=
      [truc | Identifier float | machin]*
  ;
*/</span>
RULE_IMPLEMENT(test3, p)
{
    p   >>  ( G_OR
            >>  truc().r()
            >>  ( G_AND               <span class="com">// Notez la creation du groupe AND</span>
                >>  Identifier().r()
                >>  Float().r()
                ).r()
            >>  machin().r()
            ).n('*').r()
        ;
    RULE_RETURN(p);
}
</pre>

<h3><a name="cppAST" class="sharp">Sauvegarde dans l'AST</a></h3>

<p>
	Comme pour le reste, la sauvegarde dans l'AST se fait egalement au moyen modificateurs.
</p>

<pre>
Regle().saveNode("noeud")                                     <span class="com">// => Regle:noeud</span>
Regle().saveNode("noeud", false)                              <span class="com">// => Regle:!noeud</span>
Regle().saveNode("noeud").saveLine()                          <span class="com">// => Regle:noeud.</span>
Regle().saveAttr("attr")                                      <span class="com">// => Regle:&lt;attr&gt;</span>
Regle().saveAttr("attr", "val")                               <span class="com">// => Regle:&lt;attr "val"&gt;</span>
Regle().saveNode("noeud", false).saveLine().saveAttr("attr")  <span class="com">// => Regle:!noeud.:&lt;attr&gt;</span>
</pre>

<h3><a name="cppEx" class="sharp">Exemple</a></h3>

<p>
	Reprenons l'exemple en TzBNF du chapitre precedent et transcrivons le en C++ :
</p>

<pre>
<span class="com">/*
  Test		::=
      Prec*
      Check?:!Check
      >Ignore(P_LBLANKS)
      [
          In:&ltpoint '1'&gt; ='.'
      |
          In:&ltpoint '0'&gt;
      ]:In
      >NoIgnore After?
  ;
*/</span>

RULE_IMPLEMENT(Test, p)  <span class="com">// ATTENTION : Ne pas oublier dans le .h RULE_DECLARE_SIMPLE(Test);</span>
{
    p   >>  Prec().n('*').r()
        >>  Check().n('?').saveNode("Check", false).r()
        >>  ( G_OR
            >> ( G_AND
                >>  In().saveAttr("point", "1").r()
                >>  GetChar().only('.').check(true).r()
                ).r()
            >>  In().saveAttr("point", "0").r()
            ).ignore(P_LBLANKS).saveNode("In").r()
        >>  After().n('?').ignoreBefore(false).r()
        ;
    RULE_RETURN(p);
}
</pre>

<p>
	Bien que plus dificile a lire, cette syntaxe est aussi simple que celle de la TzBNF.<br />
	Elle vous sera utile lors de l'ecriture de parsers plus avances qui necessiterons du code C++ directement dans les regles ou lors de l'utilisation de fonctionnalitees avancees de TzParser (voir chapitre correspondant plus bas).
</p>

<h2><a name='use' class="sharp">Utiliser un parser en C++ cree ou genere avec TzParser</a></h2>

<h3><a name='useBase' class="sharp">Utilisation basique</a></h3>

<p>
	Il est inutile de parser un flux, si ce n'est pour en retirer un AST.<br />
	TzParser ne fournis pas un systeme d'AST mais une interface permettant d'interfacer n'importe quel systeme d'AST.<br />
	TzParser est fournis avec l'adaptateur permettant d'utiliser <a href="http://www.grinninglizard.com/tinyxml/">TinyXML</a> comme librairie AST.<br />
	Voici un exemple commente pour utiliser TzParser dans un programme C++ (on admet que Rules.h et Rules.cpp sont les fichiers des regles TzParser, et que TRACE est un define pour true ou false) :
</p>

<pre>
#include "tzParse/tzParse.h"             <span class="com">// On inclus la librairie tzParse</span>

#include "tzParse/ASTAdapt/TzTinyXML.h"  <span class="com">// On inclus l'adaptateur de l'AST pour TinyXML</span>
                                         <span class="com">//   (qui incluera tinyXML)</span>

#include "Rules.h"                       <span class="com">// On inclus le header des regles</span>

using namespace tzParse;                 <span class="com">// Afin d'acceder facilement au parser</span>

int	main()
{
    try
    {
        Parser              p;           <span class="com">// On cree le parser</span>
        TzTinyXMLDocument   d;           <span class="com">// On cree le document tinyXML adapte au systeme d'AST</span>

        p.setXMLDoc(&d);                 <span class="com">// On definit le document a remplir au parser</span>

        if (TRACE)
            p.trace();                   <span class="com">// On trace eventuellement le parcours du parser.</span>
                                         <span class="com">//   ATTENTION : TRES verbeux et TRES lent (bourin).</span>

        ifstream    f("masyntaxe.txt");  <span class="com">// On ouvre le fichier qui va etre parse.</span>

        p   <<  f;                       <span class="com">// On insere le flux dans le parser.</span>

        p   >>  RegleBase().r();         <span class="com">// On parse la regle RegleBase.</span>

        <span class="com">/*
          Ce bloc de code est specifique a TinyXML et permet d'afficher l'arbre XML.
        */</span>
        {
            TiXmlPrinter    printer;
            printer.SetIndent( "    " );
            d.Accept(&printer);
            cout << printer.CStr();
        }
    }

    catch (std::exception& e)            <span class="com">// Les exceptions de TinyXML et de TzParse heritent de</span>
                                         <span class="com">//   std::exception</span>
    {
        cout << e.what() << endl;
    }

    return 0;
}
</pre>

<h3><a name='useStream' class="sharp">Creer un stream pour TzParser</a></h3>

<p>
	Notez l'instruction (dans l'exemple precedent) p << f; ou f est un ifstream.<br />
	L'insertion d'un flux dans un TzParser peux prendre en parametre n'importe quel istream ou objet heritant de IParseData.<br />
	Voici l'interface IParseData (definie dans IParseData.h) qui vous permet de creer vos propres flux a parser :	
</p>

<pre>
class IParseData
{
public:
    <span class="com">/*
      Methode a surcharger qui renvoie le prochain caractere a lire.
    */</span>
    virtual char    getChar(void) = 0;

    <span class="com">/*
      Methode a surcharger qui renvoie true si le flux est vide, false s'il reste des caracteres a
      lire.
    */</span>
    virtual bool    isEndOfFile(void) = 0;

    virtual ~IParseData() {};  <span class="com">// Destructeur virtuel</span>
};
</pre>

<p>
	Attention : Les IParseData doivent se comporter comme les istream en ce qui concerne la fin du fichier, c'est a dire que isEndOfFile ne doit renvoyer true qu'apres que getChar n'ai renvoye un "caractere de fin du fichier" (habituellement -1, mais pas obligatoire) qui sera ignore par le parser.
</p>

<h3><a name='useAST' class="sharp">Interfacer une librairie AST</a></h3>

<p>
	TzParser permet d'utiliser n'importe quel librairie (XML ou non) fournissant un document a remplir des elements parses.<br />
	Cependant, meme s'il est possible d'utiliser d'autres systemes que le XML, TzParser utilisera ces librairies comme s'il s'agissait de librairie XML.<br />
	Voici les 2 interfaces a surcharger pour interfacer une librairie pour l'AST :
</p>

<pre>
class IParseASTElement
{
public:
    <span class="com">/*
      Methode a surcharger qui prend en parametre un IParseASTElement* qui est FORCEMENT de la
      classe renvoyee par IParseASTDocument::createElement, vous pouvez donc le downcaster avec
      dynamic_cast sans probleme.
      ATTENTION : Si vous copiez child, vous devez le supprimer (delete child);
    */</span>
    virtual void    addChild(IParseASTElement* child) = 0;

    <span class="com">/*
      Ajoute un attribut a l'element
    */</span>
    virtual void    setAttribute(const std::string& name, const std::string& value) = 0;

    virtual ~TzTinyXMLElement() {}  <span class="com">// Destructeur virtuel</span>
};

class IParseASTDocument
{
public:
    <span class="com">/*
      Meme methode que IParseASTElement::addChild.
    */</span>
    virtual void                addChild(IParseASTElement*) = 0;

    <span class="com">/*
      Cree un element qui pourra etre ajoute au document ou a un element via addChild.
    */</span>
    virtual IParseASTElement*   createElement(const std::string& name) = 0;

    virtual ~TzTinyXMLDocument() {}  <span class="com">// Destructeur virtuel</span>
};
</pre>

<p>
	Pour bien comprendre la creation d'un adaptateur AST, il est conseille de consulter le fichier ASTAdapt/TzTinyXML.h qui adapte tres simplement la librairie TinyXML.
</p>

<h2><a name="moreCPP" class="sharp">Creer des regles avancees en C++</a></h2>

<p>
	La librairie TzParser permet de creer des regles avancees, c'est a dire des regles disposant, a l'instar de GetChar, des modificateurs propres.<br />
	Attention : pour l'instant il n'est pas possible d'utiliser de telles regles dans dans un parser ecris en TzNBNF. A partir du moment ou vous utilises les regles avancees, vous devez (pour l'instant) ecrire tout votre parser en C++.
</p>

<p>
    La definition des modificateurs se fait dans le .h. A la place de RULE_DECLARE_SIMPLE, voici comment declarer une regle avancee (nommee Test) :
</p>

<pre>
RULE_DECLARE_HEAD(Test)                          <span class="com">// Signature de la classe</span>
{
    RULE_HEAD(Test);                             <span class="com">// Obligatoire : implemente les constructeurs</span>
    RULE_SIMPLE_CLONE(Test);                     <span class="com">// Obligqtoire : implemente la methode clone</span>

    RULE_NO_TRACE();                             <span class="com">// A NE METTRE QUE SI VOUS NE SOUHAITEZ PAS QUE</span>
                                                 <span class="com">//   LA REGLE S'AFFICHE DANS LE TRACE</span>

    RULE_ARG(_a, bool, false);                   <span class="com">// Cree un attribut bool _a par defaut a false</span>
    RULE_METHARG_DEF(Test, a1, _a, bool, true);  <span class="com">// Cree un modificateur a1 affecte a _a et dont</span>
                                                 <span class="com">//   l'argument est optionnel par defaut a true</span>
    RULE_METHARG(Test, a2, _a, bool);            <span class="com">// Cree un modificateur a2 affecte a _a</span>

    RULE_ARGNULL(_b, char*);                     <span class="com">// Cree un attribut char* _b par defaut a NULL</span>
                                                 <span class="com">//   Attention, pour initialiser des pointeurs a</span>
                                                 <span class="com">//   NULL, vous devez utiliser RULE_ARGNULL car</span>
                                                 <span class="com">//   RULE_ARG(_a, char*, 0) ne fonctionne pas sous</span>
                                                 <span class="com">//   G++...</span>
    RULE_METHARG(Test, b, _b, char*);            <span class="com">// Cree un modificateur b affecte a _b</span>

    RULE_STDARG(Test, c, char, '1');             <span class="com">// Equivalent a (notez l'ajout de l'underscore) :</span>
                                                 <span class="com">//   RULE_ARG(_c, char, '1');</span>
                                                 <span class="com">//   RULE_METHARG(Test, c, _c, char);</span>

    RULE_STDARG_DEF(Test, d, char, '1', '2');    <span class="com">// Equivalent a (notez l'ajout de l'underscore) :</span>
                                                 <span class="com">//   RULE_ARG(_d, char, '1');</span>
                                                 <span class="com">//   RULE_METHARG_DEF(Test, d, _d, char, '2');</span>

    RULE_STDARGNULL(Test, e, const char*);       <span class="com">// Equivalent a (notez l'ajout de l'underscore) :</span>
                                                 <span class="com">//   RULE_ARGNULL(_e, const char*);</span>
                                                 <span class="com">//   RULE_METHARG(Test, e, _e, const char*);</span>

    RULE_STDARGNULL_DEF(Test, f, char*, "abc");  <span class="com">// Equivalent a (notez l'ajout de l'underscore) :</span>
                                                 <span class="com">//   RULE_ARGNULL(_f, char*);</span>
                                                 <span class="com">//   RULE_METHARG_DEF(Test, f, _f, char*, "abc");</span>

};                                               <span class="com">// Notez le ; (il s'agit d'une classe)</span>
</pre>

<p>
	Notez que RULE_ARG, RULE_ARGNULL, RULE_METHARG et RULE_METHARG_DEF sont rarement utilise au profit de RULE_STDARG, RULE_STDARG_DEF, RULE_STDARGNULL et RULE_STDARGNULL_DEF qui, en plus de declarer les attribut, implemente leur modificateurs.<br />
	Une fois dans RULE_IMPLEMENT, il faut utiliser l'operateur * pour acceder aux arguments. Par exemple, pour acceder a la valeur char _d de l'exemple precedent, il faut faire *_d. Ceci s'explique par le fait que ce n'est pas un char qui est cree mais un AutoInit&lt;char, '1'&gt;.<br />
	Pour bien comprendre le fonctionnement des regles avancees, vous etes invite a regarder les fichiers TzParseDefaultRules.h et TzParseDefaultRules.cpp qui contiennent les regles par defaut de TzParser (beaucoup sont des regles avancees relativement simple).
</p>

<h2><a name="end" class="sharp">Bug ? Contact ? Next ?</a></h2>

<p>
	En cas de Bug, merci de vous rendre sur le bugtracker du projet.
</p>

<p>
	En cas d'incomprehension ou de besoin d'aide, vous etes invites a vous rendre sur le forum du projet ou j'essaierai de repondre le plus rapidement a vos questions.<br />
	Si vous souhaitez me contacter, n'hesitez pas a le faire (en francais ou en anglais) : salomon . brys @ gmail . com
</p>

<p>
	Pour voir ou proposer des fonctionnalitees a venir, rendez vous sur la wishList du projet.
</p>

<p>
	TzParser est sous licence LIBRE si votre projet est LIBRE (ce qui ne veux pas forcement dire open-source) et sous licence COMMERCIALE si votre projet est COMMERCIAL (ce qui ne veux pas forcement dire close-source).
	A chacune des 2 licence s'applique des particularites, merci de consulter le fichier LICENCE.txt si vous utilisez TzParser dans votre projet.
</p>


</body>
</html>
