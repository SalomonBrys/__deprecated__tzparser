Each instruction is on 3 bytes : the first is the number of the command, the two
other may be a short int pointing to the argument(s) or the argument(s) itself.

Commands:
0x01: SAVE_CONTEXT
0x02: RESTORE_CONTEXT
0x03: CANCEL_CONTEXT

0x10: IGNORE
0x11: SET_IGNORE: unsigned short int pointing to the IGNORE rule

0x20: READ_CHAR
0x21: READ_A_CHAR: first byte = the character to read, second byte unused
0x22: READ_CHAR_RANGE: first byte = starting character, second byte = ending character
0x23: READ_CHAR_IN: unsigned short int pointing to a null terminated character array containing all the characters to read

0x30: SET_SF: first byte = 0 to set FAIL, 1 to set SUCCESS, second byte unused

0x40: IF : first byte = what to test (FAIL or SUCCESS), second byte = if there is an ELSE (0 = no, 1 = yes)

0x50: LOAD: unsigned short int pointing to the code to load 
0x51: GO_BACK
0x52: GO_TO: unsigned short int pointig to the code to go to

0xF0: RESTORE_CONTEXT_AND_GO_BACK
0xF1: CANCEL_CONTEXT_AND_GO_BACK

Arguments:
FAIL: 0
SUCCESS: 1

NO_ELSE: 0 (default)
ELSE: 1

===============================================================================

simpleCString	::=
	'"' #ReadChar('a', 'z') '"'
;

:simpleCString

SAVE_CONTEXT

IGNORE
READ_CHAR '"'
IF FAIL
RESTORE_CONTEXT_AND_GO_BACK

IGNORE
READ_CHAR_RANGE 'a', 'z'
IF FAIL
RESTORE_CONTEXT_AND_GO_BACK

IGNORE
READ_CHAR '"'
IF FAIL
RESTORE_CONTEXT_AND_GO_BACK

CANCEL_CONTEXT_AND_GO_BACK

===============================================================================

IdentifierStart ::=
	[#ReadChar('a', 'z') | #ReadChar('A', 'Z') | #ReadChar('_')]
;

:IdentifierStart

SAVE_CONTEXT

IGNORE
SAVE_CONTEXT

READ_CHAR_RANGE 'a', 'z'
IF FAIL, ELSE
RESTORE_CONTEXT
GO_TO :0

READ_CHAR_RANGE 'A', 'Z'
IF FAIL, ELSE
RESTORE_CONTEXT
GO_TO :0

READ_CHAR '_'

:0
CANCEL_CONTEXT

IF FAIL
RESTORE_CONTEXT_AND_GO_BACK

CANCEL_CONTEXT_AND_GO_BACK

===============================================================================

Repeaters	::=
	#ReadChar('a')+ #ReadChar('b')? #ReadChar('c') #readChar('d')*
;

:Repeaters

SAVE_CONTEXT

IGNORE
READ_CHAR 'a'
IF FAIL
GO_TO :1
:0
IGNORE
READ_CHAR 'a'
if sucess
GO_TO :0
SET_SF SUCCESS
:1
IF FAIL
RESTORE_CONTEXT_AND_GO_BACK

IGNORE
READ_CHAR 'b'

IGNORE
READ_CHAR 'c'
IF FAIL
RESTORE_CONTEXT_AND_GO_BACK

:1
IGNORE
READ_CHAR 'd'
IF SUCCESS
GO_TO :1

CANCEL_CONTEXT_AND_GO_BACK

===============================================================================

IdentifierEnd ::=
	[#ReadChar('a', 'z') | #ReadChar('A', 'Z') | #ReadChar('0', '9') | #ReadChar('_')]*
;

:IdentifierEnd

SAVE_CONTEXT

:0
IGNORE
SAVE_CONTEXT

READ_CHAR_RANGE 'a', 'z'
IF FAIL, ELSE
RESTORE_CONTEXT
GO_TO :1

READ_CHAR_RANGE 'A', 'Z'
IF FAIL, ELSE
RESTORE_CONTEXT
GO_TO :1

READ_CHAR_RANGE '0', '9'
IF FAIL, ELSE
RESTORE_CONTEXT
GO_TO :1

READ_CHAR '_'

:1
CANCEL_CONTEXT

IF SUCCESS
GO_TO :0
SET_SF SUCCESS

CANCEL_CONTEXT_AND_GO_BACK

===============================================================================

Identifier	::=
	IdentifierStart IdentifierEnd
;

:Identifier

SAVE_CONTEXT

IGNORE
LOAD :IdentifierStart
IF FAIL
RESTORE_CONTEXT_AND_GO_BACK

IGNORE
LOAD :IdentifierEnd
IF FAIL
RESTORE_CONTEXT_AND_GO_BACK

CANCEL_CONTEXT_AND_GO_BACK

===============================================================================

GroupWithRepeaters	::=
	[#ReadChar('a')+ | #ReadChar('b')? | #ReadChar('c') | #readChar('d')*]
;

:Repeaters

SAVE_CONTEXT

IGNORE
SAVE_CONTEXT

READ_CHAR 'a'
IF FAIL
GO_TO :1
:0
IGNORE
READ_CHAR 'a'
if sucess
GO_TO :0
SET_SF SUCCESS
:1
IF SUCCESS
GO_TO :3

READ_CHAR 'b'
GO_TO :3

READ_CHAR 'c'
IF SUCCESS
GO_TO :3

:2
IGNORE
READ_CHAR 'd'
IF SUCCESS
GO_TO :2
SET_SF SUCCESS

:3
CANCEL_CONTEXT

IF FAIL
RESTORE_CONTEXT_AND_GO_BACK

CANCEL_CONTEXT_AND_GO_BACK
